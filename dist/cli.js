#!/usr/bin/env node
var D=Object.defineProperty;var u=(i,e)=>D(i,"name",{value:e,configurable:!0});import{Command as L}from"@commander-js/extra-typings";import{f as y,h as k,L as v,R as x,C as O,g as E,j as T,d as F}from"./consoleWriter-BQkmvA7p.js";import w from"yaml";import{access as C,mkdir as I,writeFile as W,appendFile as R}from"node:fs/promises";import{homedir as S}from"node:os";import"@anthropic-ai/sdk";import"zod";import"@google/genai";import"openai";import"serialize-error";import"fs/promises";import"glob";import"node:path";import"chalk";import"node:readline";var _="0.5.0",$={version:_};function J(i,e){if(typeof i!="object"||i===null)return e&&(e.value="Config: must be a non-null object"),!1;if("openai"in i){const t=i.openai;if(typeof t!="object"||t===null)return e&&(e.value="Config: openai must be an object"),!1;if(typeof t["api-key"]!="string")return e&&(e.value="Config: openai.api-key must be a string"),!1;if("model"in t&&typeof t.model!="string")return e&&(e.value="Config: openai.model must be a string"),!1}if("anthropic"in i){const t=i.anthropic;if(typeof t!="object"||t===null)return e&&(e.value="Config: anthropic must be an object"),!1;if(typeof t["api-key"]!="string")return e&&(e.value="Config: anthropic.api-key must be a string"),!1;if("model"in t&&typeof t.model!="string")return e&&(e.value="Config: anthropic.model must be a string"),!1}if("ollama"in i){const t=i.ollama;if(typeof t!="object"||t===null)return e&&(e.value="Config: ollama must be an object"),!1;if("url"in t&&typeof t.url!="string")return e&&(e.value="Config: ollama.url must be a string"),!1;if("model"in t&&typeof t.model!="string")return e&&(e.value="Config: ollama.model must be a string"),!1}if("googleai"in i){const t=i.googleai;if(typeof t!="object"||t===null)return e&&(e.value="Config: googleai must be an object"),!1;if(typeof t["api-key"]!="string")return e&&(e.value="Config: googleai.api-key must be a string"),!1;if("model"in t&&typeof t.model!="string")return e&&(e.value="Config: googleai.model must be a string"),!1}if("brave"in i){const t=i.brave;if(typeof t!="object"||t===null)return e&&(e.value="Config: brave must be an object"),!1;if(typeof t["api-key"]!="string")return e&&(e.value="Config: brave.api-key must be a string"),!1;if("rateLimit"in t&&typeof t.rateLimit!="number")return e&&(e.value="Config: brave.rateLimit must be a number"),!1}return!0}u(J,"isServiceConfig");const N="ax.job",P=["yaml","yml","json"];async function U(i,e){const{recorder:t}=e,{content:a,format:l}=await y(i,{defaults:{name:N,formats:P},tag:"Job File"});let n=null;if(l==="json")n=JSON.parse(a);else if(l==="yaml"||l==="yml")n=w.parse(a);else throw new Error("Invalid job file format");t?.debug?.heading.log("The Job Object"),t?.debug?.log(n);const g={value:""};if(k(n,g))return n;throw new Error(`The job file is not valid: ${g.value}`)}u(U,"getJobConfig");const z="ax.config",M=["yaml","yml","json"];async function G(i,e){const{recorder:t}=e,{content:a,format:l}=await y(i,{defaults:{name:z,formats:M},tag:"Config File"});let n=null;if(l==="json")n=JSON.parse(a);else if(l==="yaml"||l==="yml")n=w.parse(a);else throw new Error("Invalid config file format");t?.debug?.heading.log("The Config Object"),t?.debug?.log(n);const g={value:""};if(J(n,g))return n;throw new Error(g.value)}u(G,"getServiceConfig");const p="./logs/",B="~/.axle/logs/";class H{static{u(this,"LogWriter")}time;initialized=!1;logDir=p;pendingWrites=[];constructor(){this.time=new Date().toISOString()}get filename(){return`${this.logDir}${this.time}.log`}async initialize(){try{await C(p),this.logDir=p}catch{const a=B.replace("~",S());try{await C(a),this.logDir=a}catch{await I(a,{recursive:!0}),this.logDir=a}}const e=W(this.filename,`AXLE: New run at ${this.time}
`);this.pendingWrites.push(e);try{await e,this.initialized=!0}finally{const t=this.pendingWrites.indexOf(e);t!==-1&&this.pendingWrites.splice(t,1)}}async writeToLog(e){const{time:t,level:a,payload:l}=e;this.initialized||await this.initialize();const n=l.map(r=>typeof r=="string"?r:JSON.stringify(r)),g=`${v[a]} ${new Date(t).toISOString()} > ${n.join(" >> ")}
`,c=R(this.filename,g).catch(r=>{console.error(`Failed to write to log file: ${r}`)});this.pendingWrites.push(c);try{await c}finally{const r=this.pendingWrites.indexOf(c);r!==-1&&this.pendingWrites.splice(r,1)}}async handleEvent(e){await this.writeToLog(e)}async flush(){this.pendingWrites.length>0&&await Promise.all(this.pendingWrites)}}const f=new L().name("axle").description("Axle is a CLI tool for running AI workflows").version($.version).option("--dry-run","Run the application without executing against the AI providers").option("-c, --config <path>","Path to the config file").option("-j, --job <path>","Path to the job file").option("--no-log","Do not write the output to a log file").option("--no-warn-unused","Do not warn about unused variables").option("--no-inline","Do not inline the console output").option("-d, --debug","Print additional debug information").option("--truncate <num>","Truncate printed strings to a certain number of characters, 0 to disable",parseInt,100).option("--args <args...>","Additional arguments in the form key=value");f.parse(process.argv);const s=f.opts(),m={};s.args&&s.args.forEach(i=>{const[e,t]=i.split("=");e&&t&&(m[e.trim()]=t.trim())}),process.on("uncaughtException",async i=>{console.error("Uncaught exception:"),console.error(i),o&&(o.error?.log("Uncaught exception:"),o.error?.log(i.message),o.error?.log(i.stack||""),await o.shutdown()),process.exit(1)});const o=new x;s.debug&&(o.level=v.Debug);const X=new O(s);if(o.subscribe(X),s.log){const i=new H;await i.initialize(),o.subscribe(i)}s.debug&&(o.debug?.heading.log("Options"),o.debug?.log(s),o.debug?.heading.log("Additional Arguments:"),o.debug?.log(m));let d,b;try{d=await G(s.config??null,{recorder:o}),b=await U(s.job??null,{recorder:o})}catch(i){o.error.log(i.message),o.debug?.log(i.stack),await o.shutdown(),f.outputHelp(),process.exit(1)}let j;try{const{engine:i,...e}=b.using,t={...d[i],...e};j=E(i,t)}catch(i){o.error.log(i.message),o.error.log(i.stack),await o.shutdown(),f.outputHelp(),process.exit(1)}T().setConfig(d),o.info?.heading.log("All systems operational. Running job...");const K=Date.now();s.dryRun&&o.info?.log("Dry run mode enabled. No API calls will be made.");const h={in:0,out:0},A=await F(b.jobs).execute({provider:j,variables:m,options:s,stats:h,recorder:o});A&&(o.info?.heading.log("Response"),o.info.log(A)),o.info?.heading.log("Usage"),o.info?.log(`Total run time: ${Date.now()-K}ms`),o.info?.log(`Input tokens: ${h.in} `),o.info?.log(`Output tokens: ${h.out} `),o.info?.heading.log("Complete. Goodbye"),await o.shutdown();
