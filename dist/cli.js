#!/usr/bin/env node
var C=Object.defineProperty;var f=(o,t)=>C(o,"name",{value:t,configurable:!0});import{Command as O}from"@commander-js/extra-typings";import{f as b,h as L,j as E,L as y,R as T,C as $,g as F,k as I,d as W}from"./consoleWriter-Bi-2iqiA.js";import v from"yaml";import{ZodError as j}from"zod";import{access as A,mkdir as k,writeFile as S,appendFile as R}from"node:fs/promises";import{homedir as _}from"node:os";import"@anthropic-ai/sdk";import"@google/genai";import"openai";import"serialize-error";import"fs/promises";import"glob";import"node:path";import"chalk";import"node:readline";var N="0.5.0",J={version:N};const M="ax.job",P=["yaml","yml","json"];async function U(o,t){const{recorder:i}=t,{content:r,format:l}=await b(o,{defaults:{name:M,formats:P},tag:"Job File"});let s=null;if(l==="json")s=JSON.parse(r);else if(l==="yaml"||l==="yml")s=v.parse(r);else throw new Error("Invalid job file format");i?.debug?.heading.log("The Job Object"),i?.debug?.log(s);try{return E.parse(s)}catch(g){if(g instanceof j){const c=g.issues.map(n=>`${n.path.join(".")}: ${n.message}`).join("; ");throw new Error(`The job file is not valid: ${c}`)}throw g}}f(U,"getJobConfig");const z="ax.config",G=["yaml","yml","json"];async function B(o,t){const{recorder:i}=t,{content:r,format:l}=await b(o,{defaults:{name:z,formats:G},tag:"Config File"});let s=null;if(l==="json")s=JSON.parse(r);else if(l==="yaml"||l==="yml")s=v.parse(r);else throw new Error("Invalid config file format");i?.debug?.heading.log("The Config Object"),i?.debug?.log(s);try{return L.parse(s)}catch(g){if(g instanceof j){const c=g.issues.map(n=>`${n.path.join(".")}: ${n.message}`).join("; ");throw new Error(`The config file is not valid: ${c}`)}throw g}}f(B,"getServiceConfig");const d="./logs/",H="~/.axle/logs/";class X{static{f(this,"LogWriter")}time;initialized=!1;logDir=d;pendingWrites=[];constructor(){this.time=new Date().toISOString()}get filename(){return`${this.logDir}${this.time}.log`}async initialize(){try{await A(d),this.logDir=d}catch{const r=H.replace("~",_());try{await A(r),this.logDir=r}catch{await k(r,{recursive:!0}),this.logDir=r}}const t=S(this.filename,`AXLE: New run at ${this.time}
`);this.pendingWrites.push(t);try{await t,this.initialized=!0}finally{const i=this.pendingWrites.indexOf(t);i!==-1&&this.pendingWrites.splice(i,1)}}async writeToLog(t){const{time:i,level:r,payload:l}=t;this.initialized||await this.initialize();const s=l.map(n=>typeof n=="string"?n:JSON.stringify(n)),g=`${y[r]} ${new Date(i).toISOString()} > ${s.join(" >> ")}
`,c=R(this.filename,g).catch(n=>{console.error(`Failed to write to log file: ${n}`)});this.pendingWrites.push(c);try{await c}finally{const n=this.pendingWrites.indexOf(c);n!==-1&&this.pendingWrites.splice(n,1)}}async handleEvent(t){await this.writeToLog(t)}async flush(){this.pendingWrites.length>0&&await Promise.all(this.pendingWrites)}}const p=new O().name("axle").description("Axle is a CLI tool for running AI workflows").version(J.version).option("--dry-run","Run the application without executing against the AI providers").option("-c, --config <path>","Path to the config file").option("-j, --job <path>","Path to the job file").option("--no-log","Do not write the output to a log file").option("--no-warn-unused","Do not warn about unused variables").option("--no-inline","Do not inline the console output").option("-d, --debug","Print additional debug information").option("--truncate <num>","Truncate printed strings to a certain number of characters, 0 to disable",parseInt,100).option("--args <args...>","Additional arguments in the form key=value");p.parse(process.argv);const a=p.opts(),u={};a.args&&a.args.forEach(o=>{const[t,i]=o.split("=");t&&i&&(u[t.trim()]=i.trim())}),process.on("uncaughtException",async o=>{console.error("Uncaught exception:"),console.error(o),e&&(e.error?.log("Uncaught exception:"),e.error?.log(o.message),e.error?.log(o.stack||""),await e.shutdown()),process.exit(1)});const e=new T;a.debug&&(e.level=y.Debug);const K=new $(a);if(e.subscribe(K),a.log){const o=new X;await o.initialize(),e.subscribe(o)}a.debug&&(e.debug?.heading.log("Options"),e.debug?.log(a),e.debug?.heading.log("Additional Arguments:"),e.debug?.log(u));let h,m;try{h=await B(a.config??null,{recorder:e}),m=await U(a.job??null,{recorder:e})}catch(o){e.error.log(o.message),e.debug?.log(o.stack),await e.shutdown(),p.outputHelp(),process.exit(1)}let D;try{const{engine:o,...t}=m.using,i={...h[o],...t};D=F(o,i)}catch(o){e.error.log(o.message),e.error.log(o.stack),await e.shutdown(),p.outputHelp(),process.exit(1)}I().setConfig(h),e.info?.heading.log("All systems operational. Running job...");const Y=Date.now();a.dryRun&&e.info?.log("Dry run mode enabled. No API calls will be made.");const w={in:0,out:0},x=await W(m.jobs).execute({provider:D,variables:u,options:a,stats:w,recorder:e});x&&(e.info?.heading.log("Response"),e.info.log(x)),e.info?.heading.log("Usage"),e.info?.log(`Total run time: ${Date.now()-Y}ms`),e.info?.log(`Input tokens: ${w.in} `),e.info?.log(`Output tokens: ${w.out} `),e.info?.heading.log("Complete. Goodbye"),await e.shutdown();
