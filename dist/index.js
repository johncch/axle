var d=Object.defineProperty;var i=(o,t)=>d(o,"name",{value:t,configurable:!0});import{R as g,A as n,g as m,s as h,d as u,l as c,a as f,i as k,b as w}from"./consoleWriter-vHL92Ioi.js";import{C as D,I as F,L as $,W as G,e as q,c as U}from"./consoleWriter-vHL92Ioi.js";import"@anthropic-ai/sdk";import*as x from"zod";import"@google/genai";import"openai";import"serialize-error";import"fs/promises";import"glob";import"node:fs/promises";import"node:path";import"chalk";import"node:readline";class y{static{i(this,"StreamParts")}listeners={start:new Set,text:new Set,thinking:new Set,"tool-call":new Set,"tool-call-complete":new Set,complete:new Set};isComplete=!1;on(t,e){return this.listeners[t].add(e),this}emit(t,...e){const s=this.listeners[t];if(s)for(const r of s)r(...e)}id="";model="";parts=[];finishReason;stats;get partsLength(){return this.parts.length}get currentId(){return this.id}start(t,e){this.id=t,this.model=e,this.emit("start",t)}complete(t,e){if(this.isComplete)return;this.finishReason=t,this.stats=e,this.isComplete=!0;const s={role:"assistant",content:this.parts.filter(r=>r.type==="text"||r.type==="thinking"),toolCalls:this.parts.filter(r=>r.type==="tool-call"),id:this.id,model:this.model};this.emit("complete",s)}createText(t,e){if(t<this.parts.length)throw new Error(`Cannot create text at index ${t} because it already exists`);this.parts.push({type:"text",text:e}),this.emit("text",e)}updateText(t,e){const s=this.getPart(t,"text");s&&(s.text+=e,this.emit("text",s.text))}createToolCall(t,e,s){if(t<this.parts.length)throw new Error(`Cannot create tool-call at index ${t} because it already exists`);this.parts.push({type:"tool-call",id:e,name:s,parameters:{}}),this.emit("tool-call",e,s)}completeToolCall(t,e){const s=this.getPart(t,"tool-call");s&&(s.parameters=e,this.emit("tool-call-complete",s.id,s.name,e))}createThinking(t,e){if(t<this.parts.length)throw new Error(`Cannot create thinking at index ${t} because it already exists`);this.parts.push({type:"thinking",text:e}),this.emit("thinking",e)}updateThinking(t,e){const s=this.getPart(t,"thinking");s&&(s.text+=e,this.emit("thinking",e))}getPart(t,e){if(t<0||t>=this.parts.length)return null;const s=this.parts[t];return s.type===e?s:null}get currentMessage(){return{role:"assistant",content:[...this.parts.filter(t=>t.type==="text"||t.type==="thinking")],toolCalls:[...this.parts.filter(t=>t.type==="tool-call")],id:this.id,model:this.model,...this.finishReason?{finishReason:this.finishReason}:{}}}}function P(o){const{provider:t,messages:e,tools:s,recorder:r}=o,a=t.createStreamingRequest?.({messages:e,tools:s,context:{recorder:r}});return console.log(a),new b(a)}i(P,"stream");class b{static{i(this,"StreamResultImpl")}constructor(t){this.streamSource=t,this.streamParts=new y,this.messagePromise=new Promise((e,s)=>{this.resolveMessage=e,this.rejectMessage=s}),this.streamParts.on("complete",e=>{this.resolveMessage?.(e)}),this.startProcessing()}streamParts;messagePromise;resolveMessage;rejectMessage;chunkListeners=new Set;processingStarted=!1;async*[Symbol.asyncIterator](){const t=[];let e=null,s=!1;const r=i(a=>{e?(e(a),e=null):t.push(a)},"listener");this.chunkListeners.add(r);try{for(;!s;){let a;t.length>0?a=t.shift():a=await new Promise(p=>{e=p}),a===null?s=!0:(yield a,(a.type==="complete"||a.type==="error")&&(s=!0))}}finally{this.chunkListeners.delete(r)}}async startProcessing(){if(!this.processingStarted){this.processingStarted=!0;try{for await(const t of this.streamSource)switch(this.chunkListeners.forEach(e=>e(t)),t.type){case"start":this.streamParts.start(t.id,t.data.model);break;case"text":const e=t.data.index;e>=this.streamParts.partsLength?this.streamParts.createText(e,t.data.text):this.streamParts.updateText(e,t.data.text);break;case"thinking-start":this.streamParts.createThinking(t.data.index,"");break;case"thinking-delta":this.streamParts.updateThinking(t.data.index,t.data.text);break;case"tool-call-start":this.streamParts.createToolCall(t.data.index,t.data.id,t.data.name);break;case"tool-call-complete":this.streamParts.completeToolCall(t.data.index,t.data.arguments);break;case"complete":this.streamParts.complete(t.data.finishReason,t.data.usage);break;case"error":this.rejectMessage?.(new Error(t.data.error));return}}catch(t){this.rejectMessage?.(t instanceof Error?t:new Error(String(t)))}finally{this.chunkListeners.forEach(t=>t(null))}}}get message(){return this.messagePromise}get current(){return this.streamParts.currentMessage}}class S{static{i(this,"Axle")}provider;stats={in:0,out:0};variables={};recorder=new g;constructor(t){if(Object.entries(t).length!==1)throw new n("Must have exactly one config");try{const e=Object.keys(t)[0],s=t[e];this.provider=m(e,s)}catch(e){throw e instanceof n?e:new n("Failed to initialize provider",{code:"PROVIDER_INIT_ERROR",cause:e instanceof Error?e:new Error(String(e))})}}addWriter(t){this.recorder.subscribe(t)}async execute(...t){try{let e;return e=await h(...t).execute({provider:this.provider,variables:this.variables,stats:this.stats,recorder:this.recorder}),e}catch(e){const s=e instanceof n?e:new n("Execution failed",{cause:e instanceof Error?e:new Error(String(e))});return this.recorder.error?.log(s),{response:null,error:s,success:!1}}}async executeDAG(t,e={},s){try{return await u(t,s).execute({provider:this.provider,variables:{...this.variables,...e},stats:this.stats,recorder:this.recorder})}catch(r){const a=r instanceof n?r:new n("DAG execution failed",{cause:r instanceof Error?r:new Error(String(r))});return this.recorder.error?.log(a),{response:null,error:a,success:!1}}}get logs(){return this.recorder.getLogs()}static async loadFileContent(t,e){return e==="utf-8"?c(t,"utf-8"):e==="base64"?c(t,"base64"):c(t)}}class l extends f{static{i(this,"ChainOfThought")}constructor(t,e){super(t,e)}static with(t,e){if(!e)return new l(t,{response:x.string()});if(k(e))return new l(t,e);{const s=w(e);return new l(t,s)}}createInstructions(t=""){return super.createInstructions(`Let's think step by step. Use <thinking></thinking> tags to show your reasoning and thought process.

`)}finalize(t,e={}){const s=super.finalize(t,e),r=this.parseTaggedSections(t);let a="thinking";return"thinking"in r.tags||("think"in r.tags?(a="think",e.recorder?.warn?.log("No <thinking> section found in the response but found <think> instead. This may be a limitation of the model or prompt.")):e.recorder?.warn?.log("No <thinking> section found in the response. Please ensure your response includes a <thinking> tag.")),{...s,thinking:r.tags[a]||""}}}export{S as Axle,l as ChainOfThought,D as ConsoleWriter,F as Instruct,$ as LogLevel,G as WriteOutputTask,q as concurrentWorkflow,u as dagWorkflow,U as generate,h as serialWorkflow,P as stream};
