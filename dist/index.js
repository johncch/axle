var m=Object.defineProperty;var n=(l,t)=>m(l,"name",{value:t,configurable:!0});import{R as g,A as o,g as f,s as p,d,l as u,a as w,i as k,b as x}from"./consoleWriter-CELfzW62.js";import{C as M,I as $,L as G,W as q,e as U,c as B}from"./consoleWriter-CELfzW62.js";import"@anthropic-ai/sdk";import*as y from"zod";import"@google/genai";import"openai";import"serialize-error";import"fs/promises";import"glob";import"node:fs/promises";import"node:path";import"chalk";import"node:readline";class P{static{n(this,"StreamParts")}listeners={start:new Set,text:new Set,thinking:new Set,"tool-call":new Set,"tool-call-complete":new Set,complete:new Set};isComplete=!1;on(t,e){return this.listeners[t].add(e),this}emit(t,...e){const r=this.listeners[t];if(r)for(const s of r)s(...e)}id="";model="";parts=[];finishReason;stats;get partsLength(){return this.parts.length}get currentId(){return this.id}start(t,e){this.id=t,this.model=e,this.emit("start",t)}complete(t,e){if(this.isComplete)return;this.finishReason=t,this.stats=e,this.isComplete=!0;const r=this.parts.filter(a=>a.type==="text"||a.type==="thinking"),s=this.parts.filter(a=>a.type==="tool-call"),i=r.filter(a=>a.type==="text").map(a=>a.text).join(""),c={type:"success",role:"assistant",id:this.id,model:this.model,content:r,toolCalls:s.length>0?s:void 0,finishReason:t,usage:e,text:i,raw:{}};this.emit("complete",c)}error(t,e,r,s){if(this.isComplete)return;this.isComplete=!0;const i={type:"error",error:{type:t,message:e},usage:r,raw:s};this.emit("complete",i)}createText(t,e){if(t<this.parts.length)throw new Error(`Cannot create text at index ${t} because it already exists`);this.parts.push({type:"text",text:e}),this.emit("text",e)}updateText(t,e){const r=this.getPart(t,"text");r&&(r.text+=e,this.emit("text",r.text))}createToolCall(t,e,r){if(t<this.parts.length)throw new Error(`Cannot create tool-call at index ${t} because it already exists`);this.parts.push({type:"tool-call",id:e,name:r,parameters:{}}),this.emit("tool-call",e,r)}completeToolCall(t,e){const r=this.getPart(t,"tool-call");r&&(r.parameters=e,this.emit("tool-call-complete",r.id,r.name,e))}createThinking(t,e){if(t<this.parts.length)throw new Error(`Cannot create thinking at index ${t} because it already exists`);this.parts.push({type:"thinking",text:e}),this.emit("thinking",e)}updateThinking(t,e){const r=this.getPart(t,"thinking");r&&(r.text+=e,this.emit("thinking",e))}getPart(t,e){if(t<0||t>=this.parts.length)return null;const r=this.parts[t];return r.type===e?r:null}get currentMessage(){return{role:"assistant",content:[...this.parts.filter(t=>t.type==="text"||t.type==="thinking")],toolCalls:[...this.parts.filter(t=>t.type==="tool-call")],id:this.id,model:this.model,...this.finishReason?{finishReason:this.finishReason}:{}}}}function b(l){const{provider:t,messages:e,system:r,tools:s,recorder:i,options:c}=l,a=t.createStreamingRequest?.({messages:e,system:r,tools:s,context:{recorder:i},options:c});return console.log(a),new S(a)}n(b,"stream");class S{static{n(this,"StreamResultImpl")}constructor(t){this.streamSource=t,this.streamParts=new P,this.finalPromise=new Promise((e,r)=>{this.resolveFinal=e,this.rejectFinal=r}),this.streamParts.on("complete",e=>{this.resolveFinal?.(e)}),this.startProcessing()}streamParts;finalPromise;resolveFinal;rejectFinal;chunkListeners=new Set;processingStarted=!1;async*[Symbol.asyncIterator](){const t=[];let e=null,r=!1;const s=n(i=>{e?(e(i),e=null):t.push(i)},"listener");this.chunkListeners.add(s);try{for(;!r;){let i;t.length>0?i=t.shift():i=await new Promise(c=>{e=c}),i===null?r=!0:(yield i,(i.type==="complete"||i.type==="error")&&(r=!0))}}finally{this.chunkListeners.delete(s)}}async startProcessing(){if(!this.processingStarted){this.processingStarted=!0;try{for await(const t of this.streamSource)switch(this.chunkListeners.forEach(e=>e(t)),t.type){case"start":this.streamParts.start(t.id,t.data.model);break;case"text":const e=t.data.index;e>=this.streamParts.partsLength?this.streamParts.createText(e,t.data.text):this.streamParts.updateText(e,t.data.text);break;case"thinking-start":this.streamParts.createThinking(t.data.index,"");break;case"thinking-delta":this.streamParts.updateThinking(t.data.index,t.data.text);break;case"tool-call-start":this.streamParts.createToolCall(t.data.index,t.data.id,t.data.name);break;case"tool-call-complete":this.streamParts.completeToolCall(t.data.index,t.data.arguments);break;case"complete":this.streamParts.complete(t.data.finishReason,t.data.usage);break;case"error":this.streamParts.error(t.data.type,t.data.message,t.data.usage,t.data.raw);return}}catch(t){this.rejectFinal?.(t instanceof Error?t:new Error(String(t)))}finally{this.chunkListeners.forEach(t=>t(null))}}}get final(){return this.finalPromise}get current(){return this.streamParts.currentMessage}}class v{static{n(this,"Axle")}provider;stats={in:0,out:0};variables={};recorder=new g;constructor(t){if(Object.entries(t).length!==1)throw new o("Must have exactly one config");try{const e=Object.keys(t)[0],r=t[e];this.provider=f(e,r)}catch(e){throw e instanceof o?e:new o("Failed to initialize provider",{code:"PROVIDER_INIT_ERROR",cause:e instanceof Error?e:new Error(String(e))})}}addWriter(t){this.recorder.subscribe(t)}async execute(...t){try{let e;return e=await p(...t).execute({provider:this.provider,variables:this.variables,stats:this.stats,recorder:this.recorder}),e}catch(e){const r=e instanceof o?e:new o("Execution failed",{cause:e instanceof Error?e:new Error(String(e))});return this.recorder.error?.log(r),{response:null,error:r,success:!1}}}async executeDAG(t,e={},r){try{return await d(t,r).execute({provider:this.provider,variables:{...this.variables,...e},stats:this.stats,recorder:this.recorder})}catch(s){const i=s instanceof o?s:new o("DAG execution failed",{cause:s instanceof Error?s:new Error(String(s))});return this.recorder.error?.log(i),{response:null,error:i,success:!1}}}get logs(){return this.recorder.getLogs()}static async loadFileContent(t,e){return e==="utf-8"?u(t,"utf-8"):e==="base64"?u(t,"base64"):u(t)}}class h extends w{static{n(this,"ChainOfThought")}constructor(t,e){super(t,e)}static with(t,e){if(!e)return new h(t,{response:y.string()});if(k(e))return new h(t,e);{const r=x(e);return new h(t,r)}}createInstructions(t=""){return super.createInstructions(`Let's think step by step. Use <thinking></thinking> tags to show your reasoning and thought process.

`)}finalize(t,e={}){const r=super.finalize(t,e),s=this.parseTaggedSections(t);let i="thinking";return"thinking"in s.tags||("think"in s.tags?(i="think",e.recorder?.warn?.log("No <thinking> section found in the response but found <think> instead. This may be a limitation of the model or prompt.")):e.recorder?.warn?.log("No <thinking> section found in the response. Please ensure your response includes a <thinking> tag.")),{...r,thinking:s.tags[i]||""}}}export{v as Axle,h as ChainOfThought,M as ConsoleWriter,$ as Instruct,G as LogLevel,q as WriteOutputTask,U as concurrentWorkflow,d as dagWorkflow,B as generate,p as serialWorkflow,b as stream};
